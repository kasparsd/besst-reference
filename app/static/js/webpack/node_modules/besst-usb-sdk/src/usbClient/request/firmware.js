/**
 * USB Client Request - Firmware update
 * @module request/firmware-update
 */

const q = require("q");
const crc = require("crc");
const async = require("async");
const handler = require("./handler");
const eventsHandler = require("../eventsHandler");
const events = eventsHandler.events;
const nestedError = require("nested-error-stacks");
const device = require("../device");

/**
 * Uploads a series of firmware data packs
 * @function
 * @param {string} packs - upload data packs
 * @param {string} total - total number of data packs to upload
 * @return {string} promise
 */
function uploadPacks(packs, total) {
  let deferred = q.defer();
  let counter = 0;
  async.eachOfLimit(
    packs,
    1,
    (pack, index, callback) => {
      handler
        .request({
          buffer: pack,
        })
        .then((res) => {
          if (res.data === 1) {
            if (counter >= 20 || index >= total) {
              //Dont spam events
              counter = 0;

              /**
               * Update progress for firmware update
               * @event firmware-update-progress
               * @returns {number} total - total number of packets to send
               * @returns {number} upload - current packet index
               */
              events.emit("firmware-update-progress", {
                total: total,
                upload: index + 1,
              });
            } else {
              counter++;
            }
            callback();
          } else {
            return callback(new nestedError("Failed to upload part 1"));
          }
        })
        .catch((err) => {
          return callback(new nestedError("Failed to upload part 2", err));
        });
    },
    (err) => {
      if (err) {
        deferred.reject(err);
      } else {
        /**
         * Update progress for firmware update
         * @event firmware-update-progress
         * @returns {number} total - total number of packets to send
         * @returns {number} upload - current packet index
         */
        events.emit("firmware-update-progress", {
          total: total,
          upload: total,
        });
        handler
          .request(
            {
              deferred: deferred,
            },
            true
          )
          .then((res) => {
            if (res.hexCode === 0x26) {
              deferred.resolve(res);
            }
          });
      }
    }
  );
  return deferred.promise;
}

/**
 * Update the firmware on USB
 * @function
 * @param {Buffer} buffer - buffer array containing all the packs of data to send
 * @param {Object} options - allow for reconnectedWait and rebootWait configuration
 * @return {string} promise
 */
module.exports.update = (buffer, options) => {
  if (options == null || options == undefined) {
    options = {};
  }

  if (!options.reconnectedWait) {
    options.reconnectedWait = 1000;
  }
  if (!options.rebootWait) {
    options.rebootWait = 2000;
  }

  if (!buffer || buffer.length === 0) {
    return q.reject(new nestedError("empty payload"));
  } else {
    let deferred = q.defer();
    buffer = Buffer.from(buffer);
    let fileInfo = buffer.slice(0, 16);
    let fileInfo2 = buffer.slice(16, 32);
    let isBesstAppfirmware =
      parseInt(fileInfo.slice(2, 3).toString("hex"), 16) === 0xfc;

    let fileContentBuffer = buffer.slice(16);
    let fileCrc = crc.crc16xmodem(fileContentBuffer).toString(16);
    fileCrc = ("0000" + fileCrc).substr(-4);

    let contentLen = fileContentBuffer.length;
    const packs = [];
    //file info

    let lenHex = ("00000000" + contentLen.toString(16)).substr(-8);
    let lenBuf = Buffer.from(lenHex, "hex");
    let arr = [0, 0, 0, 0];

    for (let j = 0; j < lenBuf.length; j++) {
      arr[arr.length - 1 - j] = lenBuf[lenBuf.length - 1 - j];
    }

    // let fst = false;
    // for(let i=4; i<16; i++ ){
    //     if(fileInfo[i]!== 0){
    //         fst = true;
    //     }
    // }
    // let sec = false;
    // for(let i=2; i<16; i++ ){
    //     if(fileInfo2[i]!== 0){
    //         sec = true;
    //     }
    // }
    let dataBuf = [];
    let headData = "";
    // 就是第3个字节 是0X8X就是can协议，如果是0x0x就是uart协议
    // 如果第3个字节是在128-150范围则是CAN 协议，否则是UART
    // 24 uart 发送文件大小信息
    // 29 是can 发送大小信息

    // 第4个字节是判断can 版本是2.0还是3.0， 0x40 代表3.0,0x20 代表 2.0

    const device_type = fileInfo[2];
    const can_version = fileInfo[4];

    if (device_type > 0x80 && device_type < 0x96) {
      //can
      let fileContentBuffer_32 = buffer.slice(32);
      let fileCrc_32 = crc.crc16xmodem(fileContentBuffer_32).toString(16);
      fileCrc_32 = ("0000" + fileCrc_32).substr(-4);
      let bufferCrc = Buffer.from(fileInfo2.slice(0, 2)).toString("hex");

      console.log("file", fileCrc_32, "Buffer", bufferCrc);
      if (can_version == 0x40) {
        // can 3.0 校验crc  
        // 0x84电池忽略校验CRC

        if (fileCrc_32 === bufferCrc || device_type === 0x84) {
          headData = "0029000009" + Buffer.from(arr).toString("hex") + fileCrc;
          dataBuf = Buffer.concat(
            [Buffer.from(headData, "hex"), fileInfo.slice(0, 5)],
            65
          );
        } else {
          throw new nestedError("Firmware crc check failed.");
        }
      } else {
        // can 2.0 不校验走uart 发包格式
        headData = "0024000009" + Buffer.from(arr).toString("hex") + fileCrc;
        dataBuf = Buffer.concat(
          [Buffer.from(headData, "hex"), fileInfo.slice(0, 3)],
          65
        );
      }
    } else if (
      (device_type > 0x00 && device_type < 0x0f) ||
      isBesstAppfirmware
    ) {
      // uart
      headData = "0024000009" + Buffer.from(arr).toString("hex") + fileCrc;
      dataBuf = Buffer.concat(
        [Buffer.from(headData, "hex"), fileInfo.slice(0, 3)],
        65
      );
    }

    packs.push(dataBuf);
    let packSize = Math.ceil(contentLen / 60);
    for (let i = 0; i < packSize; i++) {
      let start = i * 60;
      let end;
      if (contentLen - start <= 60) {
        end = contentLen;
      } else {
        end = (i + 1) * 60;
      }
      let buf = fileContentBuffer.slice(start, end);
      let seqchrL = Buffer.from([i & 0xff]);
      let seqchrH = Buffer.from([(i >> 8) & 0xff]);
      let packetBuf = Buffer.concat(
        [
          Buffer.from([0x00, 0x23]),
          seqchrH,
          seqchrL,
          Buffer.from([buf.length]),
          buf,
        ],
        65
      );
      packs.push(packetBuf);
    }
    let total = packs.length;

    // if the firmware is for besst box will send the first request. besst box will rebot to DFU and the pid changed to 0614. than reconnected ans send the data as common upgrade buffer data
    console.log("DFU Model:" + device.dfuEnabled(), total);
    let delayForSendPack = 0;
    if (isBesstAppfirmware && device.dfuEnabled() === false) {
      // upgrade the besst firmware
      let pack = Buffer.concat([Buffer.from("0025", "hex")], 65);
      handler.request({
        buffer: pack,
      });
      delayForSendPack = options.rebootWait + options.reconnectedWait;
      setTimeout(() => {
        device.connect();
      }, options.rebootWait);
    } else {
      if (!device.connect()) {
        device.connect();
        delayForSendPack = 1500;
      } else {
        delayForSendPack = 500;
      }
    }

    setTimeout(function () {
      uploadPacks(packs, total)
        .then((res) => {
          deferred.resolve(res);
        })
        .catch((err) => {
          deferred.reject(err);
        });
    }, delayForSendPack);

    return deferred.promise;
  }
};



//////////////////
// WEBPACK FOOTER
// ./node_modules/besst-usb-sdk/src/usbClient/request/firmware.js
// module id = 1230
// module chunks = 76