/**
 * USB Client Request - CAN
 * @module request/can
 */

const q = require('q');
const async = require('async');
const common = require('../common');
const handler = require('./handler');
const nestedError = require('nested-error-stacks');


/**
 * Adds a get request to the queue to fetch back a single field
 * @function getDeviceType
 * @param {string} usbCommand - defaults to common.USB_CMD.USB_CMD_PC_TO_CAN
 * @param {string} source - defaults to common.DEVICE.BST
 * @param {string} target - defaults to common.DEVICE.HMI
 * @param {string} can - defaults to common.CAN.READ_CMD
 * @param {string} code - operation main code
 * @param {string} subCode - operation sub code
 * @param {string} payload - payload to send through
 * @param {string} deferred - promise for when the request has been completed
 * @param {string} piroitise - add the request to the top of the queue stack
 * @param {string} doNotWait - do not wait for a reponse from USB device, as soon as request is sent resolve the deferred promise
 * @param {string} response - 
 * @return {string} promise
 */
module.exports.get = (usbCommand, source, target, can, code, subCode, payload, deferred, piroitise = false, doNotWait = false, response={dataPacks:[]}) => {
    return handler.request({
        usbCommand: usbCommand || common.USB_CMD.USB_CMD_PC_TO_CAN,
        source: source || common.DEVICE.BST,
        target: target || common.DEVICE.HMI,
        can: can || common.CAN.READ_CMD,
        code: code,
        subCode: subCode,
        payload: payload,
        deferred: deferred,
        doNotWait: doNotWait,
        response: response
    }, piroitise)
}

//
/**
 * Adds an update request to the queue to modify a single value
 * Requests are sent with the following CAN codes
 * common.CAN.WRITE_CMD
 * common.CAN.LONG_START_CMD
 * common.CAN.LONG_TRANG_CMD
 * common.CAN.LONG_END_CMD
 * @function getDeviceType
 * @param {string} usbCommand - usb command
 * @param {string} source - signal source
 * @param {string} target - signal target
 * @param {string} code - operation main code
 * @param {string} subCode - operation sub code
 * @param {string} payload - payload to send through 
 * @return {string} promise
 */
module.exports.update = (usbCommand, source, target, code, subCode, payload) => {
    if (payload === undefined || payload === null) {
        return q.reject(new nestedError('Null or undefined payload'));
    } else {
        let hexData = payload;
        if (hexData.length % 2 !== 0) {
            hexData = '0' + hexData;
        }
        const dataLen = hexData.length / 2;
        // if data is not empty will split with a 8 bit pacak to send
        const dataPacks = [];
        let _hexData = hexData;
        for (let i = 0; i < dataLen; i += 8) {
            dataPacks.push(_hexData.substr(0, 16));
            _hexData = _hexData.substr(16);
        }
        const startPack = dataPacks.shift();
        const endPack = dataPacks.pop() || '';
        return handler.request({
                usbCommand: usbCommand,
                source: source,
                target: target,
                can: common.CAN.WRITE_CMD,
                code: code,
                subCode: subCode,
                payload: common.numberToHexStr(dataLen)
            })
            .then(res => {
                if (res.canCode === common.CAN.NORMAL_ACK) {
                    return handler.request({
                        usbCommand: usbCommand,
                        source: source,
                        target: target,
                        can: common.CAN.LONG_START_CMD,
                        code: code,
                        subCode: subCode,
                        payload: startPack
                    }, true);
                } else {
                    throw new nestedError('Error Response ', res);
                }
            }).then(res => {
                if (res.canCode === common.CAN.NORMAL_ACK) {

                    if (dataPacks.length === 0) {
                        return res;
                    } else {
                        let deferred = q.defer();
                        async.eachOfLimit(dataPacks, 1, (pack, index, callback) => {
                            let codeIndex = common.hexAllocToStr(index, 4);
                            handler.request({
                                usbCommand: usbCommand,
                                source: source,
                                target: target,
                                can: common.CAN.LONG_TRANG_CMD,
                                code: codeIndex.substr(0, 2),
                                subCode: codeIndex.substr(2, 2),
                                payload: pack
                            }, true).then(res => {
                                if (res.canCode === common.CAN.NORMAL_ACK) {
                                    callback();
                                } else {
                                    //retry
                                    handler.request({
                                        usbCommand: usbCommand,
                                        source: source,
                                        target: target,
                                        can: common.CAN.LONG_TRANG_CMD,
                                        code: codeIndex.substr(0, 2),
                                        subCode: codeIndex.substr(2, 2),
                                        payload: pack
                                    }, true).then(res => {
                                        if (res.canCode === common.CAN.NORMAL_ACK) {
                                            callback();
                                        } else {
                                            callback(res);
                                        }
                                    });
                                }
                            }).then(res => {
                                if (res.canCode === common.CAN.NORMAL_ACK) {
                                    callback();
                                } else {
                                    callback(res);
                                }
                            });
                        }, (err) => {
                            if (err) {
                                deferred.reject(err);
                            } else {
                                deferred.resolve(res);
                            }
                        });

                        return deferred.promise;
                    }
                } else {
                    throw new nestedError("Timeout");
                }
            }).then(res => {
                if (res.canCode === common.CAN.NORMAL_ACK) {
                    let codeIndex = common.hexAllocToStr(dataPacks.length, 4);
                    return handler.request({
                        usbCommand: usbCommand,
                        source: source,
                        target: target,
                        can: common.CAN.LONG_END_CMD,
                        code: codeIndex.substr(0, 2),
                        subCode: codeIndex.substr(2, 2),
                        payload: endPack
                    }, true).then(res => {
                        if (res.canCode === common.CAN.NORMAL_ACK) {
                            return res;
                        } else {
                            throw new nestedError("Timeout");
                        }
                    });
                } else {
                    throw new nestedError("Timeout");
                }
            });
    }
}

//
/**
 * Adds a simple update request to the queue to modify a single value
 * common.CAN.WRITE_CMD
 * @function getDeviceType
 * @param {string} usbCommand - usb command
 * @param {string} source - signal source
 * @param {string} target - signal target
 * @param {string} code - operation main code
 * @param {string} subCode - operation sub code
 * @param {string} payload - payload to send through 
 * @return {string} promise
 */
module.exports.updateSimple = (usbCommand, source, target, code, subCode, payload) => {
    if (payload === undefined || payload === null) {
        return q.reject(new nestedError('Null or undefined payload'));
    } else {
        return handler.request({
            usbCommand: usbCommand || common.USB_CMD.USB_CMD_PC_TO_CAN,
            source: source || common.DEVICE.BST,
            target: target || common.DEVICE.CTL,
            can: common.CAN.WRITE_CMD,
            code: code,
            subCode: subCode,
            payload: payload
        })
    }
}


//////////////////
// WEBPACK FOOTER
// ./node_modules/besst-usb-sdk/src/usbClient/request/can.js
// module id = 472
// module chunks = 76