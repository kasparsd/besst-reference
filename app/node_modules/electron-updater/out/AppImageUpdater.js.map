{"version":3,"sources":["../src/AppImageUpdater.ts"],"names":[],"mappings":"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","sourcesContent":["import { AllPublishOptions, newError } from \"builder-util-runtime\"\nimport { execFileSync, spawn } from \"child_process\"\nimport isDev from \"electron-is-dev\"\nimport { chmod, unlinkSync } from \"fs-extra-p\"\nimport * as path from \"path\"\nimport \"source-map-support/register\"\nimport { DownloadUpdateOptions } from \"./AppUpdater\"\nimport { BaseUpdater } from \"./BaseUpdater\"\nimport { FileWithEmbeddedBlockMapDifferentialDownloader } from \"./differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader\"\nimport { UpdateCheckResult } from \"./main\"\nimport { findFile } from \"./providers/Provider\"\n\nexport class AppImageUpdater extends BaseUpdater {\n  constructor(options?: AllPublishOptions | null, app?: any) {\n    super(options, app)\n  }\n\n  checkForUpdatesAndNotify(): Promise<UpdateCheckResult | null> {\n    if (isDev) {\n      return Promise.resolve(null)\n    }\n\n    if (process.env.APPIMAGE == null) {\n      if (process.env.SNAP == null) {\n        this._logger.warn(\"APPIMAGE env is not defined, current application is not an AppImage\")\n      }\n      else {\n        this._logger.info(\"SNAP env is defined, updater is disabled\")\n      }\n      return Promise.resolve(null)\n    }\n\n    return super.checkForUpdatesAndNotify()\n  }\n\n  /*** @private */\n  protected doDownloadUpdate(downloadUpdateOptions: DownloadUpdateOptions): Promise<Array<string>> {\n    const provider = downloadUpdateOptions.updateInfoAndProvider.provider\n    const fileInfo = findFile(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), \"AppImage\")!!\n    return this.executeDownload({\n      fileExtension: \"AppImage\",\n      fileInfo,\n      downloadUpdateOptions,\n      task: async (updateFile, downloadOptions) => {\n        const oldFile = process.env.APPIMAGE!!\n        if (oldFile == null) {\n          throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\n        }\n\n        let isDownloadFull = false\n        try {\n          await new FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, {\n            newUrl: fileInfo.url.href,\n            oldFile,\n            logger: this._logger,\n            newFile: updateFile,\n            useMultipleRangeRequest: provider.useMultipleRangeRequest,\n            requestHeaders: downloadUpdateOptions.requestHeaders,\n          })\n            .download()\n        }\n        catch (e) {\n          this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`)\n          // during test (developer machine mac) we must throw error\n          isDownloadFull = process.platform === \"linux\"\n        }\n\n        if (isDownloadFull) {\n          await this.httpExecutor.download(fileInfo.url.href, updateFile, downloadOptions)\n        }\n\n        await chmod(updateFile, 0o755)\n      },\n    })\n  }\n\n  protected async doInstall(installerPath: string, isSilent: boolean, isRunAfter: boolean): Promise<boolean> {\n    const appImageFile = process.env.APPIMAGE!!\n    if (appImageFile == null) {\n      throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\n    }\n\n    // https://stackoverflow.com/a/1712051/1910191\n    unlinkSync(appImageFile)\n\n    let destination: string\n    const existingBaseName = path.basename(appImageFile)\n    // https://github.com/electron-userland/electron-builder/issues/2964\n    // if no version in existing file name, it means that user wants to preserve current custom name\n    if (path.basename(installerPath) === existingBaseName || !/\\d+\\.\\d+\\.\\d+/.test(existingBaseName)) {\n      // no version in the file name, overwrite existing\n      destination = appImageFile\n    }\n    else {\n      destination = path.join(path.dirname(appImageFile), path.basename(installerPath))\n    }\n\n    execFileSync(\"mv\", [\"-f\", installerPath, destination])\n\n    const env: any = {\n      ...process.env,\n      APPIMAGE_SILENT_INSTALL: \"true\",\n    }\n\n    if (isRunAfter) {\n      spawn(destination, [], {\n        detached: true,\n        stdio: \"ignore\",\n        env,\n      })\n        .unref()\n    }\n    else {\n      env.APPIMAGE_EXIT_AFTER_INSTALL = \"true\"\n      execFileSync(destination, [], {env})\n    }\n    return true\n  }\n}"],"sourceRoot":""}
