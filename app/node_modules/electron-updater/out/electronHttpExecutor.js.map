{"version":3,"sources":["../src/electronHttpExecutor.ts"],"names":[],"mappings":"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","sourcesContent":["import { configureRequestOptionsFromUrl, DownloadOptions, HttpExecutor, safeGetHeader } from \"builder-util-runtime\"\nimport { net, session } from \"electron\"\nimport { RequestOptions } from \"http\"\nimport Session = Electron.Session\nimport ClientRequest = Electron.ClientRequest\n\nexport type LoginCallback = (username: string, password: string) => void\nexport const NET_SESSION_NAME = \"electron-updater\"\n\nexport function getNetSession(): Session {\n  return session.fromPartition(NET_SESSION_NAME, {\n    cache: false\n  })\n}\n\nexport class ElectronHttpExecutor extends HttpExecutor<Electron.ClientRequest> {\n  private cachedSession: Session | null = null\n\n  constructor(private readonly proxyLoginCallback?: (authInfo: any, callback: LoginCallback) => void) {\n    super()\n  }\n\n  async download(url: string, destination: string, options: DownloadOptions): Promise<string> {\n    return await options.cancellationToken.createPromise<string>((resolve, reject, onCancel) => {\n      this.doDownload({\n        ...configureRequestOptionsFromUrl(url, {\n          headers: options.headers || undefined,\n        }),\n        redirect: \"manual\",\n      }, {\n        destination,\n        options,\n        onCancel,\n        callback: error => {\n          if (error == null) {\n            resolve(destination)\n          }\n          else {\n            reject(error)\n          }\n        },\n        responseHandler: null,\n      }, 0)\n    })\n  }\n\n  async downloadToBuffer(url: string, options: DownloadOptions): Promise<Buffer> {\n    return await options.cancellationToken.createPromise<Buffer>((resolve, reject, onCancel) => {\n      let result: Buffer | null = null\n      this.doDownload({\n        ...configureRequestOptionsFromUrl(url, {\n          headers: options.headers || undefined,\n        }),\n        // because PrivateGitHubProvider requires HttpExecutor.prepareRedirectUrlOptions logic, so, we need to redirect manually\n        redirect: \"manual\",\n      }, {\n        destination: null,\n        options,\n        onCancel,\n        callback: error => {\n          if (error == null) {\n            resolve(result!!)\n          }\n          else {\n            reject(error)\n          }\n        },\n        responseHandler: (response, callback) => {\n          const contentLength = safeGetHeader(response, \"content-length\")\n          let position = -1\n          if (contentLength != null) {\n            const size = parseInt(contentLength, 10)\n            if (size > 0) {\n              if (size > 5242880) {\n                callback(new Error(\"Maximum allowed size is 5 MB\"))\n                return\n              }\n\n              result = Buffer.alloc(size)\n              position = 0\n            }\n          }\n          response.on(\"data\", (chunk: Buffer) => {\n            if (position !== -1) {\n              chunk.copy(result!!, position)\n              position += chunk.length\n            }\n            else if (result == null) {\n              result = chunk\n            }\n            else {\n              if (result.length > 5242880) {\n                callback(new Error(\"Maximum allowed size is 5 MB\"))\n                return\n              }\n              result = Buffer.concat([result, chunk])\n            }\n          })\n          response.on(\"end\", () => {\n            if (result != null && position !== -1 && position !== result.length) {\n              callback(new Error(`Received data length ${position} is not equal to expected ${result.length}`))\n            }\n            else {\n              callback(null)\n            }\n          })\n        },\n      }, 0)\n    })\n  }\n\n  createRequest(options: any, callback: (response: any) => void): any {\n    // differential downloader can call this method very often, so, better to cache session\n    if (this.cachedSession == null) {\n      this.cachedSession = getNetSession()\n    }\n\n    const request = net.request({\n      ...options,\n      session: this.cachedSession,\n    })\n    request.on(\"response\", callback)\n    if (this.proxyLoginCallback != null) {\n      request.on(\"login\", this.proxyLoginCallback)\n    }\n    return request\n  }\n  protected addRedirectHandlers(request: ClientRequest, options: RequestOptions, reject: (error: Error) => void, redirectCount: number, handler: (options: RequestOptions) => void) {\n    request.on(\"redirect\", (statusCode: number, method: string, redirectUrl: string) => {\n      // no way to modify request options, abort old and make a new one\n      // https://github.com/electron/electron/issues/11505\n      request.abort()\n\n      if (redirectCount > this.maxRedirects) {\n        reject(this.createMaxRedirectError())\n      }\n      else {\n        handler(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options))\n      }\n    })\n  }\n}"],"sourceRoot":""}
