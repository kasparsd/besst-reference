"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNetSession = getNetSession;
exports.ElectronHttpExecutor = exports.NET_SESSION_NAME = void 0;

function _bluebirdLst() {
  const data = require("bluebird-lst");

  _bluebirdLst = function () {
    return data;
  };

  return data;
}

function _builderUtilRuntime() {
  const data = require("builder-util-runtime");

  _builderUtilRuntime = function () {
    return data;
  };

  return data;
}

function _electron() {
  const data = require("electron");

  _electron = function () {
    return data;
  };

  return data;
}

const NET_SESSION_NAME = "electron-updater";
exports.NET_SESSION_NAME = NET_SESSION_NAME;

function getNetSession() {
  return _electron().session.fromPartition(NET_SESSION_NAME, {
    cache: false
  });
}

class ElectronHttpExecutor extends _builderUtilRuntime().HttpExecutor {
  constructor(proxyLoginCallback) {
    super();
    this.proxyLoginCallback = proxyLoginCallback;
    this.cachedSession = null;
  }

  download(url, destination, options) {
    var _this = this;

    return (0, _bluebirdLst().coroutine)(function* () {
      return yield options.cancellationToken.createPromise((resolve, reject, onCancel) => {
        _this.doDownload(Object.assign({}, (0, _builderUtilRuntime().configureRequestOptionsFromUrl)(url, {
          headers: options.headers || undefined
        }), {
          redirect: "manual"
        }), {
          destination,
          options,
          onCancel,
          callback: error => {
            if (error == null) {
              resolve(destination);
            } else {
              reject(error);
            }
          },
          responseHandler: null
        }, 0);
      });
    })();
  }

  downloadToBuffer(url, options) {
    var _this2 = this;

    return (0, _bluebirdLst().coroutine)(function* () {
      return yield options.cancellationToken.createPromise((resolve, reject, onCancel) => {
        let result = null;

        _this2.doDownload(Object.assign({}, (0, _builderUtilRuntime().configureRequestOptionsFromUrl)(url, {
          headers: options.headers || undefined
        }), {
          // because PrivateGitHubProvider requires HttpExecutor.prepareRedirectUrlOptions logic, so, we need to redirect manually
          redirect: "manual"
        }), {
          destination: null,
          options,
          onCancel,
          callback: error => {
            if (error == null) {
              resolve(result);
            } else {
              reject(error);
            }
          },
          responseHandler: (response, callback) => {
            const contentLength = (0, _builderUtilRuntime().safeGetHeader)(response, "content-length");
            let position = -1;

            if (contentLength != null) {
              const size = parseInt(contentLength, 10);

              if (size > 0) {
                if (size > 5242880) {
                  callback(new Error("Maximum allowed size is 5 MB"));
                  return;
                }

                result = Buffer.alloc(size);
                position = 0;
              }
            }

            response.on("data", chunk => {
              if (position !== -1) {
                chunk.copy(result, position);
                position += chunk.length;
              } else if (result == null) {
                result = chunk;
              } else {
                if (result.length > 5242880) {
                  callback(new Error("Maximum allowed size is 5 MB"));
                  return;
                }

                result = Buffer.concat([result, chunk]);
              }
            });
            response.on("end", () => {
              if (result != null && position !== -1 && position !== result.length) {
                callback(new Error(`Received data length ${position} is not equal to expected ${result.length}`));
              } else {
                callback(null);
              }
            });
          }
        }, 0);
      });
    })();
  }

  createRequest(options, callback) {
    // differential downloader can call this method very often, so, better to cache session
    if (this.cachedSession == null) {
      this.cachedSession = getNetSession();
    }

    const request = _electron().net.request(Object.assign({}, options, {
      session: this.cachedSession
    }));

    request.on("response", callback);

    if (this.proxyLoginCallback != null) {
      request.on("login", this.proxyLoginCallback);
    }

    return request;
  }

  addRedirectHandlers(request, options, reject, redirectCount, handler) {
    request.on("redirect", (statusCode, method, redirectUrl) => {
      // no way to modify request options, abort old and make a new one
      // https://github.com/electron/electron/issues/11505
      request.abort();

      if (redirectCount > this.maxRedirects) {
        reject(this.createMaxRedirectError());
      } else {
        handler(_builderUtilRuntime().HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options));
      }
    });
  }

} exports.ElectronHttpExecutor = ElectronHttpExecutor;
// __ts-babel@6.0.4
//# sourceMappingURL=electronHttpExecutor.js.map